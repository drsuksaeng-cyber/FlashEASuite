//+------------------------------------------------------------------+
//|                                  FlashEASuite V2 Integration Guide |
//|                                           Program C - Trader      |
//+------------------------------------------------------------------+

# FlashEASuite V2 - Program C (Trader) Integration Guide

## Quick Start

### 1. File Structure
```
Experts/
└── FlashEA_Trader/
    ├── FlashEA_Trader.mq5          (Main EA - to be created)
    └── Include/
        └── Network/
            ├── Protocol.mqh         ✓ (Completed)
            ├── ZmqHub.mqh          ✓ (Completed)
            └── README.txt          ✓ (Documentation)

Scripts/
└── TestNetworkingLayer.mq5         ✓ (Test EA)
```

### 2. Installation Steps

#### Step 1: Copy Network Layer
```
Copy the Network/ folder to:
<MetaTrader5>/MQL5/Include/Network/
```

#### Step 2: Verify libzmq.dll
```
Ensure libzmq.dll is in:
<MetaTrader5>/MQL5/Library/libzmq.dll

If missing, download from:
https://github.com/zeromq/libzmq/releases
```

#### Step 3: Compile Protocol.mqh
```
1. Open MetaEditor
2. Open Include/Network/Protocol.mqh
3. Press F7 to compile
4. Verify no errors
```

#### Step 4: Compile ZmqHub.mqh
```
1. Open Include/Network/ZmqHub.mqh
2. Press F7 to compile
3. Verify no errors (warnings OK)
```

#### Step 5: Test with TestNetworkingLayer.mq5
```
1. Copy TestNetworkingLayer.mq5 to Experts/
2. Compile (F7)
3. Attach to chart
4. Check Experts log for connection status
```

## Integration with Main EA

### Basic Template

```mql5
//+------------------------------------------------------------------+
//|                                           FlashEA_Trader.mq5     |
//+------------------------------------------------------------------+
#property copyright "Dr. Suksaeng Kukanok"
#property version   "2.00"
#property strict

#include <Network/ZmqHub.mqh>
#include <Network/Protocol.mqh>

// Global ZMQ Hub
CZmqHub *g_zmq_hub = NULL;

// Input parameters
input string InpBrainSub = "tcp://localhost:5556";
input string InpBrainPush = "tcp://localhost:5557";
input double InpConfidenceThreshold = 0.75;

int OnInit()
{
    // Initialize networking
    g_zmq_hub = new CZmqHub();
    if(!g_zmq_hub.Initialize(100, 1000))
    {
        Print("Failed to initialize ZMQ Hub");
        return INIT_FAILED;
    }
    
    if(!g_zmq_hub.Subscribe(InpBrainSub) || 
       !g_zmq_hub.ConnectPush(InpBrainPush))
    {
        Print("Failed to connect to Brain");
        return INIT_FAILED;
    }
    
    Print("Trader initialized successfully");
    return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
    if(g_zmq_hub != NULL)
    {
        g_zmq_hub.Disconnect();
        delete g_zmq_hub;
        g_zmq_hub = NULL;
    }
}

void OnTick()
{
    if(!g_zmq_hub.IsFullyConnected())
        return;
    
    // Non-blocking message poll
    uchar buffer[];
    while(g_zmq_hub.Poll(buffer, 0))
    {
        ENUM_MESSAGE_TYPE type = CProtocol::GetMessageType(buffer);
        
        if(type == MSG_TYPE_POLICY)
        {
            PolicyMessage policy;
            if(CProtocol::DeserializePolicyMessage(buffer, policy))
            {
                ProcessPolicy(policy);
            }
        }
    }
}

void ProcessPolicy(PolicyMessage &policy)
{
    // Validate confidence
    if(policy.confidence < InpConfidenceThreshold)
    {
        Print("Policy rejected: low confidence");
        return;
    }
    
    // Execute trade
    if(policy.action == 1) // BUY
    {
        ExecuteBuyTrade(policy);
    }
    else if(policy.action == 2) // SELL
    {
        ExecuteSellTrade(policy);
    }
    
    // Send confirmation
    g_zmq_hub.SendPolicyConfirmation(
        policy.symbol,
        policy.action,
        policy.timestamp_ms
    );
}

void ExecuteBuyTrade(PolicyMessage &policy)
{
    // Your trade execution logic
    Print("Executing BUY: ", policy.symbol);
}

void ExecuteSellTrade(PolicyMessage &policy)
{
    // Your trade execution logic
    Print("Executing SELL: ", policy.symbol);
}
```

## Performance Optimization

### 1. Non-Blocking Architecture
```mql5
void OnTick()
{
    // Process ALL available messages immediately
    uchar buffer[];
    int msg_count = 0;
    while(g_zmq_hub.Poll(buffer, 0) && msg_count < 100)
    {
        ProcessMessage(buffer);
        msg_count++;
    }
    
    // Log if buffer is overwhelmed
    if(msg_count >= 100)
    {
        Print("WARNING: Message buffer saturation");
    }
}
```

### 2. Message Batching
```mql5
// Process messages in batches
PolicyMessage policies[];
ArrayResize(policies, 0);

uchar buffer[];
while(g_zmq_hub.Poll(buffer, 0))
{
    if(CProtocol::GetMessageType(buffer) == MSG_TYPE_POLICY)
    {
        PolicyMessage policy;
        if(CProtocol::DeserializePolicyMessage(buffer, policy))
        {
            int size = ArraySize(policies);
            ArrayResize(policies, size + 1);
            policies[size] = policy;
        }
    }
}

// Process all policies together
ProcessPolicyBatch(policies);
```

### 3. Connection Monitoring
```mql5
datetime g_last_msg_time = 0;
int g_reconnect_attempts = 0;

void OnTimer()
{
    // Check for stale connection
    if(TimeCurrent() - g_last_msg_time > 30) // 30 seconds
    {
        Print("Connection stale, reconnecting...");
        ReconnectToHub();
    }
    
    // Print statistics every 60 seconds
    static datetime last_stats = 0;
    if(TimeCurrent() - last_stats >= 60)
    {
        Print(g_zmq_hub.GetStatusString());
        last_stats = TimeCurrent();
    }
}

void ReconnectToHub()
{
    g_zmq_hub.Disconnect();
    Sleep(1000);
    
    if(g_zmq_hub.Subscribe(InpBrainSub) && 
       g_zmq_hub.ConnectPush(InpBrainPush))
    {
        Print("Reconnection successful");
        g_reconnect_attempts = 0;
    }
    else
    {
        g_reconnect_attempts++;
        Print("Reconnection failed (", g_reconnect_attempts, ")");
    }
}
```

## Python Brain Integration

### Expected Python Side (Program B)

```python
import zmq
import msgpack
from dataclasses import dataclass
from typing import Dict, Any

class BrainServer:
    def __init__(self):
        self.context = zmq.Context()
        
        # PUB socket for sending policies to Trader
        self.pub_socket = self.context.socket(zmq.PUB)
        self.pub_socket.bind("tcp://*:5556")
        
        # PULL socket for receiving confirmations
        self.pull_socket = self.context.socket(zmq.PULL)
        self.pull_socket.bind("tcp://*:5557")
        
        print("Brain server started")
    
    def send_policy(self, policy: Dict[str, Any]):
        """Send policy to Trader"""
        # Must match MQL5 binary format from Protocol.mqh
        msg = self._serialize_policy(policy)
        self.pub_socket.send(msg)
    
    def receive_confirmation(self, timeout_ms: int = 100):
        """Receive confirmation from Trader"""
        if self.pull_socket.poll(timeout_ms):
            msg = self.pull_socket.recv()
            return self._deserialize_confirmation(msg)
        return None
    
    def _serialize_policy(self, policy: Dict) -> bytes:
        """Serialize to match MQL5 binary format"""
        # Implementation must match Protocol.mqh format
        pass
    
    def _deserialize_confirmation(self, msg: bytes) -> Dict:
        """Deserialize confirmation message"""
        # Implementation must match Protocol.mqh format
        pass
```

## Message Flow Architecture

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│  Program A  │         │  Program B  │         │  Program C  │
│   Feeder    │         │    Brain    │         │   Trader    │
│   (MQL5)    │         │  (Python)   │         │   (MQL5)    │
└─────────────┘         └─────────────┘         └─────────────┘
       │                       │                       │
       │  TickMessage          │                       │
       │  (PUB 5555)           │                       │
       ├──────────────────────>│                       │
       │                       │  PolicyMessage        │
       │                       │  (PUB 5556)           │
       │                       ├──────────────────────>│
       │                       │                       │
       │                       │  Confirmation         │
       │                       │  (PUSH 5557)          │
       │                       │<──────────────────────┤
       │                       │                       │
```

## Latency Targets

### Component Latency Budget

| Component                  | Target    | Max      |
|----------------------------|-----------|----------|
| Message Serialization      | < 50 µs   | < 100 µs |
| ZMQ Send/Receive          | < 500 µs  | < 1 ms   |
| Network Transport (local)  | < 100 µs  | < 500 µs |
| Policy Processing         | < 2 ms    | < 5 ms   |
| **Total End-to-End**      | **< 5 ms**| **< 10 ms**|

### Measuring Latency

```mql5
void ProcessPolicy(PolicyMessage &policy)
{
    long start_time = GetTickCount64();
    
    // Process policy
    ExecuteTrade(policy);
    
    long end_time = GetTickCount64();
    long latency_us = (end_time - start_time) * 1000;
    
    if(latency_us > 5000) // > 5ms
    {
        Print("WARNING: High latency: ", latency_us, " µs");
    }
}
```

## Troubleshooting

### Common Issues

#### 1. "Failed to initialize ZMQ context"
**Cause**: libzmq.dll missing or incompatible
**Solution**: 
```
1. Download correct libzmq.dll (64-bit for MT5)
2. Place in MQL5/Library/
3. Restart MetaTrader 5
```

#### 2. "Failed to connect SUB socket"
**Cause**: Python Brain not running or wrong port
**Solution**:
```
1. Verify Python Brain is running
2. Check port in both Python and MQL5
3. Verify firewall allows localhost connections
```

#### 3. "No messages received"
**Cause**: Subscription filter mismatch
**Solution**:
```mql5
// Use empty filter for all messages
g_zmq_hub.Subscribe("tcp://localhost:5556", "");

// Or specific filter matching Python PUB
g_zmq_hub.Subscribe("tcp://localhost:5556", "POLICY");
```

#### 4. High message loss
**Cause**: Slow message processing or small HWM
**Solution**:
```mql5
// In ZmqHub.mqh, increase high water mark:
socket.setReceiveHighWaterMark(10000); // From 1000 to 10000
```

## Testing Checklist

- [ ] Protocol.mqh compiles without errors
- [ ] ZmqHub.mqh compiles without errors
- [ ] TestNetworkingLayer.mq5 compiles and runs
- [ ] Can connect to test Python server
- [ ] Can receive test messages
- [ ] Can send confirmations
- [ ] Latency < 10ms end-to-end
- [ ] No memory leaks after 1000 messages
- [ ] Connection recovery works after disruption
- [ ] Statistics tracking is accurate

## Next Steps

1. **Complete Execution Engine**
   - Risk management
   - Order management
   - Position tracking

2. **Add Persistence Layer**
   - Trade logging
   - Performance metrics
   - Error recovery

3. **Enhance Monitoring**
   - Real-time dashboard
   - Alert system
   - Performance analytics

4. **Production Hardening**
   - Error recovery
   - Failover mechanisms
   - Load testing

## Support Resources

- MQL5 Documentation: https://www.mql5.com/en/docs
- ZeroMQ Guide: https://zguide.zeromq.org/
- FlashEASuite V2 Architecture: [Internal docs]

---
Dr. Suksaeng Kukanok
FlashEASuite V2 - Professional Trading System
